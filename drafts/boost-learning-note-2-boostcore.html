<!DOCTYPE html>
<html lang="english">
<head>
        <meta charset="utf-8" />
        <title>boost learning note (2) Boost.Core</title>
        <link rel="stylesheet" href="https://www.git.moe/theme/css/main.css" />
        <link href="https://www.git.moe/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="salt fish on the moon Atom Feed" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="https://www.git.moe/">salt fish on the moon </a></h1>
                <nav><ul>
                    <li><a href="https://www.git.moe/pages/about.html">About</a></li>
                    <li class="active"><a href="https://www.git.moe/category/note.html">note</a></li>
                    <li><a href="https://www.git.moe/category/record.html">record</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="https://www.git.moe/drafts/boost-learning-note-2-boostcore.html" rel="bookmark"
           title="Permalink to boost learning note (2) Boost.Core">boost learning note (2) Boost.Core</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2018-11-20T00:00:00+08:00">
                Published: 周二 20 十一月 2018
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://www.git.moe/author/fx-moon.html">fx-moon</a>
        </address>
<p>In <a href="https://www.git.moe/category/note.html">note</a>.</p>
<p>tags: <a href="https://www.git.moe/tag/boost.html">boost</a> </p>
</footer><!-- /.post-info -->      <h1>Introduction</h1>
<p>The Boost.Core library is a collection of core utilities.
The criteria for inclusion is that the utility component be:</p>
<ul>
<li>simple</li>
<li>used by other Boost librarys, and</li>
<li>not dependent on any other Boost modules except Core itself, Config, Assert, Static Assert, or Predef.</li>
</ul>
<h1>addressof</h1>
<h2>Overview</h2>
<p>The header <code>&lt;boost/core/addressof.hpp&gt;</code> defines the function template <code>boost::addressof.boost::addressof(x)</code> returns the address of x.
Ordinarily, this address can be obtained by <code>&amp;x</code>, but the unary <code>&amp;</code> operator can be overloaded.
boost::addressof avoids calling used-defined <code>operator&amp;()</code>.</p>
<h2>Synopsis</h2>
<div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">boost</span>
<span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">T</span><span class="o">*</span> <span class="n">addressof</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h2>Example</h2>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;boost/core/addressof.hpp&gt;</span><span class="cp"></span>
<span class="k">struct</span> <span class="n">useless_type</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">nonaddressable</span>
<span class="p">{</span>
    <span class="n">useless_type</span> <span class="k">operator</span><span class="o">&amp;</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">nonaddressable</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">nonaddressable</span><span class="o">*</span> <span class="n">xp</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">addressof</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="c1">// nonaddressable* xpe = &amp;x; /*error*/</span>
<span class="p">}</span>
</pre></div>


<h2>Notes</h2>
<blockquote>
<p>In C++11 and above. boost::address is conditionally constexpr when possible. This is indicated by BOOST_CORE_NO_CONSTEXPR_ADDRESSOF not being defined.</p>
<p>With supported compilers, boost::addressof is always constexpr by leveraging compiler intrinsics. This is indicated by BOOST_CORE_HAS_BUILTIN_ADDRESSOF being defined.</p>
</blockquote>
<h1>checked_delete</h1>
<h2>Overview</h2>
<p>The header <code>&lt;boost/checked_delete.hpp&gt;</code> defines two function templates, <code>checked_delete</code> and <code>checked_array_delete</code>, and two class templates, <code>checked_deleter</code> and <code>checked_array_deleter</code>.</p>
<p>The C++ Standard allows, in 5.3.5/5, pointers to incomplete class types to be deleted with a delete-expression. When the class has a non-trivial destructor, or a class-specific operator delete, the behavior is undefined. Some compilers issue a warning when an incomplete type is deleted, but unfortunately, not all do, and programmers sometimes ignore or disable warnings.</p>
<p>A particularly troublesome case is when a smart pointer's destructor, such as <code>boost::scoped_ptr&lt;T&gt;::~scoped_ptr</code>, is instantiated with an incomplete type. This can often lead to silent, hard to track failures.</p>
<p>The supplied function and class templates can be used to prevent these problems, as they require a complete type, and cause a compilation error otherwise.</p>
<h2>Synopsis</h2>
<div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">boost</span>
<span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">checked_delete</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">);</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">checked_array_delete</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">);</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">checked_deleter</span><span class="p">;</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">checked_array_deleter</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h2>checked_delete</h2>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span><span class="kt">void</span> <span class="n">checked_delete</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">);</span>
</pre></div>


<ul>
<li>Requires: T must be a complete type. The expression <code>delete p</code> must be well-formed.</li>
<li>Effects: <code>delete p;</code></li>
</ul>
<h2>checked_array_delete</h2>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">checked_array_delete</span><span class="p">(</span><span class="n">T</span> <span class="o">*</span> <span class="n">p</span><span class="p">);</span>
</pre></div>


<ul>
<li>Requires: T must be a complete type. The expression <code>delete [] p</code> must be well formed.</li>
<li>Effects: <code>delete [] p;</code></li>
</ul>
<h1>demangle</h1>
<h2>Overview</h2>
<p>The header <code>&lt;boost/core/demangle.hpp&gt;</code> defines several tools for undecorating symbol names.</p>
<h2>Synopsis</h2>
<div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">boost</span>
<span class="p">{</span>

<span class="k">namespace</span> <span class="n">core</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">demangle</span><span class="p">(</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="n">name</span> <span class="p">);</span>

    <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="nf">demangle_alloc</span><span class="p">(</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="n">name</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">demangle_free</span><span class="p">(</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="n">demangled_name</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">class</span> <span class="nc">scoped_demangled_name</span>
    <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">explicit</span> <span class="n">scoped_demangled_name</span><span class="p">(</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="n">name</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
        <span class="o">~</span><span class="n">scoped_demangled_name</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
        <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="nf">get</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

        <span class="n">scoped_demangled_name</span><span class="p">(</span> <span class="n">scoped_demangled_name</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="n">scoped_demangled_name</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span> <span class="p">(</span> <span class="n">scoped_demangled_name</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="p">}</span>
</pre></div>


<h2>Conventional interface</h2>
<p>The function <code>boost::core::demangle</code> is the conventional way to obtain demangled symbol name. It takes a mangled string such as those returned by <code>typeid(T).name()</code> on certain implementations such as <code>g++</code>, and returns its demangled, human-readable, form. In case if demangling fails (e.g. if name cannot be interpreted as a mangled name) the function returns name.</p>
<h3>Example</h3>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;boost/core/demangle.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;typeinfo&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="n">name</span> <span class="o">=</span> <span class="k">typeid</span><span class="p">(</span> <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">).</span><span class="n">name</span><span class="p">();</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// prints 1XIiE</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">boost</span><span class="o">::</span><span class="n">core</span><span class="o">::</span><span class="n">demangle</span><span class="p">(</span> <span class="n">name</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// prints X&lt;int&gt;</span>
<span class="p">}</span>
</pre></div>


<h2>Low level interface</h2>
<p>In some cases more low level interface may be desirable. For example:</p>
<ul>
<li>Assuming that symbol demangling may fail, the user wants to be able to handle such errors.</li>
<li>The user needs to post-process the demangled name (e.g. remove common namespaces), and allocating a temporary string with the complete demangled name is significant overhead.</li>
</ul>
<p>The function <code>boost::core::demangle_alloc</code> performs name demangling and returns a pointer to a string with the demangled name, if succeeded, or nullptr otherwise. The returned pointer must be passed to <code>boost::core::demangle_free</code> to reclaim resources. Note that on some platforms the pointer returned by <code>boost::core::demangle_alloc</code> may refer to the string denoted by name, so this string must be kept immutable for the whole life time of the returned pointer.</p>
<p>The <code>boost::core::scoped_demangled_name</code> class is a scope guard that automates the calls to <code>boost::core::demangle_alloc</code> (on its construction) and <code>boost::core::demangle_free</code> (on destruction). The string with the demangled name can be obtained with its get method. Note that this method may return <code>nullptr</code> if demangling failed.</p>
<h3>Example</h3>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;boost/core/demangle.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;typeinfo&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="n">name</span> <span class="o">=</span> <span class="k">typeid</span><span class="p">(</span> <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">).</span><span class="n">name</span><span class="p">();</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">core</span><span class="o">::</span><span class="n">scoped_demangled_name</span> <span class="n">demangled</span><span class="p">(</span> <span class="n">name</span> <span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// prints 1XIiE</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">demangled</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">?</span> <span class="n">demangled</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">:</span> <span class="s">&quot;[unknown]&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// prints X&lt;int&gt;</span>
<span class="p">}</span>
</pre></div>


<h1>enable_if</h1>
<h2>Overview</h2>
<p>The <code>enable_if</code> family of templates is a set of tools to allow a function template or a class template specialization to include or exclude itself from a set of matching functions or specializations based on properties of its template arguments. For example, one can define function templates that are only enabled for, and thus only match, an arbitrary set of types defined by a traits class. The enable_if templates can also be applied to enable class template specializations. Applications of enable_if are discussed in length in [1] and [2].</p>
<h2>Synopsis</h2>
<div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Cond</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">enable_if</span><span class="p">;</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Cond</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">disable_if</span><span class="p">;</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Cond</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">lazy_enable_if</span><span class="p">;</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Cond</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">lazy_disable_if</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="n">B</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">enable_if_c</span><span class="p">;</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="n">B</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">disable_if_c</span><span class="p">;</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="n">B</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">lazy_enable_if_c</span><span class="p">;</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="n">B</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">lazy_disable_if_c</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h2>Background</h2>
<p>Sensible operation of template function overloading in C++ relies on the <strong>SFINAE</strong> (substitution-failure-is-not-an-error) principle [3]: if an invalid argument or return type is formed during the instantiation of a function template, the instantiation is removed from the overload resolution set instead of causing a compilation error. The following example, taken from [1], demonstrates why this is important:</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">negate</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">-</span><span class="n">i</span><span class="p">;</span> <span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="o">&gt;</span>
<span class="k">typename</span> <span class="n">F</span><span class="o">::</span><span class="n">result_type</span> <span class="n">negate</span><span class="p">(</span><span class="k">const</span> <span class="n">F</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">-</span><span class="n">f</span><span class="p">();</span> <span class="p">}</span>
</pre></div>


<p>Suppose the compiler encounters the call <code>negate(1)</code>. The first definition is obviously a better match, but the compiler must nevertheless consider (and instantiate the prototypes) of both definitions to find this out. Instantiating the latter definition with <code>F</code> as <code>int</code> would result in:</p>
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="o">::</span><span class="n">result_type</span> <span class="n">negate</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">);</span>
</pre></div>


<p>where the return type is invalid. If this were an error, adding an unrelated function template (that was never called) could break otherwise valid code. Due to the SFINAE principle the above example is not, however, erroneous. The latter definition of <code>negate</code> is simply removed from the overload resolution set.</p>
<p>The <code>enable_if</code> templates are tools for controlled creation of the <strong>SFINAE</strong> conditions.</p>
<h2>The enable_if templates</h2>
<p>The names of the <code>enable_if</code> templates have three parts: an optional <code>lazy_</code> tag, either <code>enable_if</code> or <code>disable_if</code>, and an optional <code>_c</code> tag. All eight combinations of these parts are supported. The meaning of the <code>lazy_</code> tag is described in the section below. The second part of the name indicates whether a true condition argument should enable or disable the current overload. The third part of the name indicates whether the condition argument is a <code>bool</code> value (<code>_c</code> suffix), or a type containing a <code>static bool</code> constant named <code>value</code> (no suffix). The latter version interoperates with Boost.MPL.</p>
<p>The definitions of <code>enable_if_c</code> and <code>enable_if</code> are as follows (we use <code>enable_if</code> templates unqualified but they are in the <code>boost</code> namespace).</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="n">B</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">enable_if_c</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="n">T</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">enable_if_c</span><span class="o">&lt;</span><span class="nb">false</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Cond</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">enable_if</span> <span class="p">:</span> <span class="k">public</span> <span class="n">enable_if_c</span><span class="o">&lt;</span><span class="n">Cond</span><span class="o">::</span><span class="n">value</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{};</span>
</pre></div>


<p>An instantiation of the <code>enable_if_c</code> template with the parameter <code>B</code> as <code>true</code> contains a member type <code>type</code>, defined to be <code>T</code>. If <code>B</code> is false, no such member is defined. Thus <code>enable_if_c&lt;B, T&gt;::type</code> is either a valid or an invalid type expression, depending on the value of <code>B</code>. When valid, <code>enable_if_c&lt;B, T&gt;::type</code> equals <code>T</code>. The <code>enable_if_c</code> template can thus be used for controlling when functions are considered for overload resolution and when they are not. For example, the following function is defined for all arithmetic types (according to the classification of the Boost <strong>type_traits</strong> library):</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">typename</span> <span class="n">enable_if_c</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span>
<span class="n">foo</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">t</span><span class="p">;</span> <span class="p">}</span>
</pre></div>


<p>The <code>disable_if_c</code> template is provided as well, and has the same functionality as <code>enable_if_c</code> except for the negated condition. The following function is enabled for all non-arithmetic types.</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">typename</span> <span class="n">disable_if_c</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span>
<span class="n">bar</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">t</span><span class="p">;</span> <span class="p">}</span>
</pre></div>


<p>For easier syntax in some cases and interoperation with Boost.MPL we provide versions of the <code>enable_if</code> templates taking any type with a <code>bool</code> member constant named <code>value</code> as the condition argument. The MPL <code>bool_</code>, <code>and_</code>, <code>or_</code>, and <code>not_</code> templates are likely to be useful for creating such types. Also, the traits classes in the <code>Boost.Type_traits</code> library follow this convention. For example, the above example function <code>foo</code> can be alternatively written as:</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">typename</span> <span class="n">enable_if</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span>
<span class="n">foo</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">t</span><span class="p">;</span> <span class="p">}</span>
</pre></div>


<h2>Using enable_if</h2>
<p>The <code>enable_if</code> templates are defined in <code>boost/utility/enable_if.hpp</code>, which is included by <code>boost/utility.hpp</code>.</p>
<p>With respect to function templates, <code>enable_if</code> can be used in multiple different ways:</p>
<ul>
<li>As the return type of an instantiatied function</li>
<li>As an extra parameter of an instantiated function</li>
<li>As an extra template parameter (useful only in a compiler that supports <code>C++0x</code> default arguments for function template parameters, see <a href="https://www.boost.org/doc/libs/1_68_0/libs/core/doc/html/core/enable_if.html#core.enable_if.using_enable_if.enable_if_0x"><em>Enabling function templates</em> in <code>C++0x</code></a> for details.</li>
</ul>
<p>In the previous section, the return type form of enable_if was shown. As an example of using the form of enable_if that works via an extra function parameter, the foo function in the previous section could also be written as:</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">foo</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="k">typename</span> <span class="n">enable_if</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">type</span><span class="o">*</span> <span class="n">dummy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>


<p>Hence, an extra parameter of type <code>void*</code> is added, but it is given a default value to keep the parameter hidden from client code. Note that the second template argument was not given to <code>enable_if</code>, as the default <code>void</code> gives the desired behavior.</p>
<p>Which way to write the enabler is largely a matter of taste, but for certain functions, only a subset of the options is possible:</p>
<ul>
<li>Many operators have a fixed number of arguments, thus enable_if must be used either in the return type or in an extra template parameter.</li>
<li>Functions that have a variadic parameter list must use either the return type form or an extra template parameter.</li>
<li>Constructors do not have a return type so you must use either an extra function parameter or an extra template parameter.</li>
<li>Constructors that have a variadic parameter list must an extra template parameter.</li>
<li>Conversion operators can only be written with an extra template parameter.</li>
</ul>
<h2>Enabling function templates in C++0x</h2>
<p>In a compiler which supports C++0x default arguments for function template parameters, you can enable and disable function templates by adding an additional template parameter. This approach works in all situations where you would use either the return type form of enable_if or the function parameter form, including operators, constructors, variadic function templates, and even overloaded conversion operations.</p>
<p>As an example:</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;boost/type_traits/is_arithmetic.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;boost/type_traits/is_pointer.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;boost/utility/enable_if.hpp&gt;</span><span class="cp"></span>

<span class="k">class</span> <span class="nc">test</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// A constructor that works for any argument list of size 10</span>
    <span class="k">template</span><span class="o">&lt;</span> <span class="n">class</span><span class="p">...</span> <span class="n">T</span><span class="p">,</span>
        <span class="k">typename</span> <span class="n">boost</span><span class="o">::</span><span class="n">enable_if_c</span><span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">...(</span> <span class="n">T</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">10</span><span class="p">,</span>
            <span class="kt">int</span> <span class="o">&gt;::</span><span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
    <span class="n">test</span><span class="p">(</span> <span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="p">);</span>

    <span class="c1">// A conversion operation that can convert to any arithmetic type</span>
    <span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span>
        <span class="k">typename</span> <span class="n">boost</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span> <span class="n">boost</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span> <span class="n">T</span> <span class="o">&gt;</span><span class="p">,</span>
            <span class="kt">int</span> <span class="o">&gt;::</span><span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
    <span class="k">operator</span> <span class="n">T</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// A conversion operation that can convert to any pointer type</span>
    <span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span>
        <span class="k">typename</span> <span class="n">boost</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span> <span class="n">boost</span><span class="o">::</span><span class="n">is_pointer</span><span class="o">&lt;</span> <span class="n">T</span> <span class="o">&gt;</span><span class="p">,</span>
            <span class="kt">int</span> <span class="o">&gt;::</span><span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
    <span class="k">operator</span> <span class="n">T</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Works</span>
    <span class="n">test</span> <span class="n">test_</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span> <span class="p">);</span>

    <span class="c1">// Fails as expected</span>
    <span class="n">test</span> <span class="n">fail_construction</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">);</span>

    <span class="c1">// Works by calling the conversion operator enabled for arithmetic types</span>
    <span class="kt">int</span> <span class="n">arithmetic_object</span> <span class="o">=</span> <span class="n">test_</span><span class="p">;</span>

    <span class="c1">// Works by calling the conversion operator enabled for pointer types</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">pointer_object</span> <span class="o">=</span> <span class="n">test_</span><span class="p">;</span>

    <span class="c1">// Fails as expected</span>
    <span class="k">struct</span> <span class="p">{}</span> <span class="n">fail_conversion</span> <span class="o">=</span> <span class="n">test_</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h2>Enabling template class specializations</h2>
<p>Class template specializations can be enabled or disabled with <code>enable_if</code>. One extra template parameter needs to be added for the enabler expressions. This parameter has the default value <code>void</code>. For example:</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Enable</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">A</span> <span class="p">{...};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">A</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">enable_if</span><span class="o">&lt;</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span> <span class="p">{...};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">claas</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">A</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">enable_if</span><span class="o">&lt;</span><span class="n">is_float</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span> <span class="p">{...};</span>
</pre></div>


<p>Instantiating <code>A</code> with any integral type matches the first specialization, whereas any floating point type matches the second one. All other tklypes match the primary template. The condition can be an;y compile-time boolean expression that depends on the template arguments of the dependent <code>value_type</code> from <code>T</code>if and only if <code>T::value_type</code> exists.</p>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="social">
                        <h2>social</h2>
                        <ul>
                            <li><a href="https://www.git.moe/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>

                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>